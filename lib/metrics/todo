var Scarlet = require('scarlet'),
    metrics = require('metrics'),
    Graphite = require('../lib/graphite/client'),
    os = require('os'),
    scarlet = new Scarlet();
    _ = require('lodash'),
    net = require('net');


// ---

var httpReq = require('../lib/metrics/http-request');

var foo = new httpReq();

// TODo
// - metrics/http-request.js
// - metrics/http-response.js
// - metrics/http-proxy.js
// - metrics/http-server.js
// - metrics/system.js
// - metrics.js - metrics.instrument(obj).as(foo); flush to graphite

var graphite = new Graphite( { apiKey: 'b2045390-ba37-42aa-b6cb-e9f2b5c56f47' } ); // TODO move to config

var Metrics = function () {

    var counters = { 
        pipe:        new metrics.Counter,
        status_2xx:  new metrics.Counter,
        status_3xx:  new metrics.Counter,
        status_4xx:  new metrics.Counter,
        status_5xx:  new metrics.Counter,
        connections: new metrics.Counter,
        'system.mem_process_rss':        new metrics.Counter,
        'system.mem_process_heapTotal':  new metrics.Counter,
        'system.mem_process_heapUsed':   new metrics.Counter,
        'system.load_average_1m':        new metrics.Counter
    };
    
    var timers = {    
        response_time_2xx:               new metrics.Histogram.createUniformHistogram(),
        bytes_read:                      new metrics.Histogram.createUniformHistogram()
    }

    var toString = function () {
        return {
            counters: counters,
            timers: timers
        }
    };

    var flush = function () {
        
        graphite.log(_.mapValues(counters, function(d) {
            return d.count;
        }));
  
        var t = _.map(timers, function (k, v) {
            return _.zipObject(
                    [
                        v + '.mean',
                        v + '.stdDev',
                        v + '.min',
                        v + '.max',
                        v + '.sum'
                    ],
                    [ 
                        k.mean(),
                        k.stdDev(),
                        k.min,
                        k.max,
                        k.sum
                    ]
                )
            })

        graphite.log(_.merge(t[0], t[1]));

        _.forEach(counters, function(d) {
            return d.clear();
        })
        
        _.forEach(timers, function(d) {
            return d.clear();
        })

    };

    /* api */

    // var m = new Metrics();
    //
    // m.instrument(res).as('http.req')
    // m.instrument(proxy).as('proxy')
    // 

    var instrumentProxy = function(proxy) {
        proxy.emit = _log(proxy.emit);
    }

    var instrumentServer = function(server) {
        setInterval(function () {
            server.getConnections(function (err, n) {
                counters.connections.count = n // TODO 
            })
        }, 5000)
    }
    
    var instrumentSystem = function(server) {
        setInterval(function () {
            var mem = process.memoryUsage();
            counters['system.mem_process_rss'].count = mem.rss;
            counters['system.mem_process_heapTotal'].count = mem.heapTotal;
            counters['system.mem_process_heapUsed'].count = mem.heapUsed;
            counters['system.load_average_1m'].count = _.first(os.loadavg());
        }, 5000)
    }

    var instrumentRequest = function (req) {
        req.pipe = foo.instrument(req);
    }
    
    var instrumentResponse = function (res) {
        res.writeHead = _logStatusCodes(res.writeHead, Date.now());
    };
    
    var _log = function (fn) {
        return scarlet
            .intercept(fn)
            .using(function(invocation, proceed) {
                if (invocation.args[0] === 'proxyRes') {
                    timers.bytes_read.update(invocation.args[1].connection.bytesRead);
                }
                proceed();
            }).proxy();
    };

   
    // proxy for res.writeHead - http://nodejs.org/api/http.html#http_response_writehead_statuscode_reasonphrase_headers
    var _logStatusCodes = function (fn, dt) {
        return scarlet
            .intercept(fn)
            .using(function (invocation, proceed) {
                var statusCode = parseInt(invocation.args[0].toString().charAt(0));
                switch (statusCode) {
                    case 2:
                        counters.status_2xx.inc(1);
                        timers.response_time_2xx.update(Date.now() - dt);
                        break;
                    case 3:
                        counters.status_3xx.inc(1);
                        break;
                    case 4:
                        counters.status_4xx.inc(1);
                        break;
                    case 5:
                        counters.status_5xx.inc(1);
                        break;
                    default:
                }
                proceed();
            }).proxy();
    };

    return {
        instrumentResponse: instrumentResponse,
        instrumentRequest: instrumentRequest,
        toString: toString,
        flush: flush,
        instrumentProxy: instrumentProxy,
        instrumentServer: instrumentServer,
        instrumentSystem: instrumentSystem
    };
};

module.exports = Metrics;
